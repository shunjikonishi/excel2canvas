package jp.co.flect.excel2canvas.chart;

import java.util.List;
import java.util.Iterator;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.LinkedHashMap;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonParseException;
import com.google.gson.JsonElement;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.reflect.TypeToken;

	/**
 * Flotr Defaults
Flotr.defaultOptions = {
  colors: ['#00A8F0', '#C0D800', '#CB4B4B', '#4DA74D', '#9440ED'], //=> The default colorscheme. When there are > 5 series, additional colors are generated.
  ieBackgroundColor: '#FFFFFF', // Background color for excanvas clipping
  title: null,             // => The graph's title
  subtitle: null,          // => The graph's subtitle
  shadowSize: 4,           // => size of the 'fake' shadow
  defaultType: null,       // => default series type
  HtmlText: true,          // => wether to draw the text using HTML or on the canvas
  fontColor: '#545454',    // => default font color
  fontSize: 7.5,           // => canvas' text font size
  resolution: 1,           // => resolution of the graph, to have printer-friendly graphs !
  parseFloat: true,        // => whether to preprocess data for floats (ie. if input is string)
  xaxis: {
    ticks: null,           // => format: either [1, 3] or [[1, 'a'], 3]
    minorTicks: null,      // => format: either [1, 3] or [[1, 'a'], 3]
    showLabels: true,      // => setting to true will show the axis ticks labels, hide otherwise
    showMinorLabels: false,// => true to show the axis minor ticks labels, false to hide
    labelsAngle: 0,        // => labels' angle, in degrees
    title: null,           // => axis title
    titleAngle: 0,         // => axis title's angle, in degrees
    noTicks: 5,            // => number of ticks for automagically generated ticks
    minorTickFreq: null,   // => number of minor ticks between major ticks for autogenerated ticks
    tickFormatter: Flotr.defaultTickFormatter, // => fn: number, Object -> string
    tickDecimals: null,    // => no. of decimals, null means auto
    min: null,             // => min. value to show, null means set automatically
    max: null,             // => max. value to show, null means set automatically
    autoscale: false,      // => Turns autoscaling on with true
    autoscaleMargin: 0,    // => margin in % to add if auto-setting min/max
    color: null,           // => color of the ticks
    mode: 'normal',        // => can be 'time' or 'normal'
    timeFormat: null,
    timeMode:'UTC',        // => For UTC time ('local' for local time).
    timeUnit:'millisecond',// => Unit for time (millisecond, second, minute, hour, day, month, year)
    scaling: 'linear',     // => Scaling, can be 'linear' or 'logarithmic'
    base: Math.E,
    titleAlign: 'center',
    margin: true           // => Turn off margins with false
  },
  x2axis: {},
  yaxis: {
    ticks: null,           // => format: either [1, 3] or [[1, 'a'], 3]
    minorTicks: null,      // => format: either [1, 3] or [[1, 'a'], 3]
    showLabels: true,      // => setting to true will show the axis ticks labels, hide otherwise
    showMinorLabels: false,// => true to show the axis minor ticks labels, false to hide
    labelsAngle: 0,        // => labels' angle, in degrees
    title: null,           // => axis title
    titleAngle: 90,        // => axis title's angle, in degrees
    noTicks: 5,            // => number of ticks for automagically generated ticks
    minorTickFreq: null,   // => number of minor ticks between major ticks for autogenerated ticks
    tickFormatter: Flotr.defaultTickFormatter, // => fn: number, Object -> string
    tickDecimals: null,    // => no. of decimals, null means auto
    min: null,             // => min. value to show, null means set automatically
    max: null,             // => max. value to show, null means set automatically
    autoscale: false,      // => Turns autoscaling on with true
    autoscaleMargin: 0,    // => margin in % to add if auto-setting min/max
    color: null,           // => The color of the ticks
    scaling: 'linear',     // => Scaling, can be 'linear' or 'logarithmic'
    base: Math.E,
    titleAlign: 'center',
    margin: true           // => Turn off margins with false
  },
  y2axis: {
    titleAngle: 270
  },
  grid: {
    color: '#545454',      // => primary color used for outline and labels
    backgroundColor: null, // => null for transparent, else color
    backgroundImage: null, // => background image. String or object with src, left and top
    watermarkAlpha: 0.4,   // => 
    tickColor: '#DDDDDD',  // => color used for the ticks
    labelMargin: 3,        // => margin in pixels
    verticalLines: true,   // => whether to show gridlines in vertical direction
    minorVerticalLines: null, // => whether to show gridlines for minor ticks in vertical dir.
    horizontalLines: true, // => whether to show gridlines in horizontal direction
    minorHorizontalLines: null, // => whether to show gridlines for minor ticks in horizontal dir.
    outlineWidth: 1,       // => width of the grid outline/border in pixels
    outline : 'nsew',      // => walls of the outline to display
    circular: false        // => if set to true, the grid will be circular, must be used when radars are drawn
  },
  mouse: {
    track: false,          // => true to track the mouse, no tracking otherwise
    trackAll: false,
    position: 'se',        // => position of the value box (default south-east)
    relative: false,       // => next to the mouse cursor
    trackFormatter: Flotr.defaultTrackFormatter, // => formats the values in the value box
    margin: 5,             // => margin in pixels of the valuebox
    lineColor: '#FF3F19',  // => line color of points that are drawn when mouse comes near a value of a series
    trackDecimals: 1,      // => decimals for the track values
    sensibility: 2,        // => the lower this number, the more precise you have to aim to show a value
    trackY: true,          // => whether or not to track the mouse in the y axis
    radius: 3,             // => radius of the track point
    fillColor: null,       // => color to fill our select bar with only applies to bar and similar graphs (only bars for now)
    fillOpacity: 0.4       // => opacity of the fill color, set to 1 for a solid fill, 0 hides the fill 
  }
};
 */
public class Flotr2 implements Chart, Cloneable, JsonDeserializer<Chart> {
	
	public enum Type {
		PIE,
		BAR,
		LINE,
		RADAR,
		BUBBLE
	};
	
	private Type type;
	private transient int seriesCount;
	private Option option = new Option();
	private List<Object> data = new ArrayList<Object>();
	private List<String> labels = null;
	
	private LinkedHashMap<String, String[]> cellNames = null;
	private transient Map<String, ValueInfo>  nameMap = null;
	
	public Flotr2() {
		//For JsonDeserializer
	}
	
	public Flotr2(Type type) {
		this.type = type;
		if (type == Type.BAR) {
			this.option.bars = new BarOption();
		}
		if (type == Type.LINE) {
			this.option.lines = new LineOption();
		}
		if (type == Type.RADAR) {
			this.option.radar = new RadarOption();
		}
		if (type == Type.BAR || type == Type.LINE || type == Type.RADAR) {
			this.labels = new ArrayList<String>();
		}
	}
	
	public Flotr2(Flotr2 origin) {
		this.type = origin.type;
		this.option = origin.option;//ToDo deep copy
		this.data.addAll(origin.data);
		if (origin.labels != null) {
			this.labels = new ArrayList<String>(origin.labels);
		}
	}
	
	public Type getType() { return this.type;}
	public Option getOption() { return this.option;}
	public List<Object> getData() { return this.data;}
	public List<String> getLabels() { return this.labels;}
	
	public int getSeriesCount() { return this.seriesCount;}
	public void setSeriesCount(int n) { this.seriesCount = n;}
	
	private SeriesData getTarget(String seriesName) {
		for (int i=0; i<this.data.size(); i++) {
			SeriesData target = (SeriesData)data.get(i);
			if (target.isTarget(seriesName)) {
				return target;
			}
		}
		return null;
	}
	
	public void addData(String seriesName, String name, double value) {
		switch (type) {
			case PIE:
				this.data.add(new PieData(name, value));
				break;
			case BAR:
			case LINE:
			case RADAR:
			{
				if (!this.labels.contains(name)) {
					this.labels.add(name);
				}
				SeriesData target = getTarget(seriesName);
				if (target == null) {
					int sc = 0;
					int offset = 0;
					if (type == Type.BAR && !this.option.bars.stacked) {
						sc = this.seriesCount;
						offset = this.data.size();
					}
					target = new SeriesData(seriesName, isHorizontal(), sc, offset);
					this.data.add(target);
				}
				target.addData(value);
				break;
			}
		}
	}
	
	private boolean isHorizontal() {
		return this.type == Type.BAR ? this.option.bars.horizontal : false;
	}
	
	public void addData(String seriesName, double x, double y) {
		SeriesData target = getTarget(seriesName);
		if (target == null) {
			target = new SeriesData(seriesName, false, 0, 0);
			this.data.add(target);
		}
		target.addData(x, y);
		if (this.option.xaxis == null) {
			this.option.xaxis = new Axis();
			this.option.xaxis.min = 0.0;
			this.option.xaxis.max = 0.0;
		}
		if (this.option.xaxis.max < x) {
			this.option.xaxis.max = x;
		}
		if (this.option.xaxis.min > y) {
			this.option.xaxis.min = y;
		}
	}
	
	public void addBubble(String seriesName, double x, double y, double size) {
		BubbleData target = (BubbleData)getTarget(seriesName);
		if (target == null) {
			target = new BubbleData(seriesName);
			this.data.add(target);
		}
		target.addBubble(x, y, size);
	}
	
	public static class Option {
		public String[] colors;//=> The default colorscheme. When there are > 5 series, additional colors are generated.
		//ieBackgroundColor: '#FFFFFF', // Background color for excanvas clipping
		public String title;// => The graph's title
		public String subtitle;// => The graph's subtitle
		//shadowSize: 4,           // => size of the 'fake' shadow
		//defaultType: null,       // => default series type
		//HtmlText: false,         // => wether to draw the text using HTML or on the canvas
		//fontColor: '#545454',    // => default font color
		//fontSize: 7.5,           // => canvas' text font size
		//resolution: 1,           // => resolution of the graph, to have printer-friendly graphs !
		//parseFloat: true,        // => whether to preprocess data for floats (ie. if input is string)
		public Axis xaxis = null;
		//x2axis: {},
		public Axis yaxis = null;
		//y2axis: { titleAngle: 270},
		public Grid grid = null;
		public Mouse mouse = null;
		public Legend legend = null;
		
		public PieOption pie = null;
		public BarOption bars = null;
		public LineOption lines = null;
		public RadarOption radar = null;
		public BubbleOption bubbles = null;
	}
	
	public static class Axis {
		//ticks: null,           // => format: either [1, 3] or [[1, 'a'], 3]
		//minorTicks: null,      // => format: either [1, 3] or [[1, 'a'], 3]
		public Boolean showLabels;// => setting to true will show the axis ticks labels, hide otherwise
		//showMinorLabels: false,// => true to show the axis minor ticks labels, false to hide
		//labelsAngle: 0,        // => labels' angle, in degrees
		public String title;     //: null,           // => axis title
		//titleAngle: 0,         // => axis title's angle, in degrees
		//noTicks: 5,            // => number of ticks for automagically generated ticks
		//minorTickFreq: null,   // => number of minor ticks between major ticks for autogenerated ticks
		//tickFormatter: Flotr.defaultTickFormatter, // => fn: number, Object -> string
		//tickDecimals: null,    // => no. of decimals, null means auto
		public Double min;//min: null,             // => min. value to show, null means set automatically
		public Double max;//max: null,             // => max. value to show, null means set automatically
		//autoscale: false,      // => Turns autoscaling on with true
		//autoscaleMargin: 0,    // => margin in % to add if auto-setting min/max
		//color: null,           // => color of the ticks
		//mode: 'normal',        // => can be 'time' or 'normal'
		//timeFormat: null,
		//timeMode:'UTC',        // => For UTC time ('local' for local time).
		//timeUnit:'millisecond',// => Unit for time (millisecond, second, minute, hour, day, month, year)
		//scaling: 'linear',     // => Scaling, can be 'linear' or 'logarithmic'
		//base: Math.E,
		//titleAlign: 'center',
		//margin: true           // => Turn off margins with false
	}
	
	public static class Grid {
		//color: '#545454',      // => primary color used for outline and labels
		//backgroundColor: null, // => null for transparent, else color
		//backgroundImage: null, // => background image. String or object with src, left and top
		//watermarkAlpha: 0.4,   // => 
		//tickColor: '#DDDDDD',  // => color used for the ticks
		//labelMargin: 3,        // => margin in pixels
		public boolean verticalLines;// => whether to show gridlines in vertical direction
		//minorVerticalLines: null, // => whether to show gridlines for minor ticks in vertical dir.
		public boolean horizontalLines;//horizontalLines: true, // => whether to show gridlines in horizontal direction
		//minorHorizontalLines: null, // => whether to show gridlines for minor ticks in horizontal dir.
		//outlineWidth: 1,       // => width of the grid outline/border in pixels
		//outline : 'nsew',      // => walls of the outline to display
		//circular: false        // => if set to true, the grid will be circular, must be used when radars are drawn
		
		public Grid(boolean vl, boolean hl) {
			this.verticalLines = vl;
			this.horizontalLines = hl;
		}
	}
	
	public static class Mouse {
		//track: false,          // => true to track the mouse, no tracking otherwise
		//trackAll: false,
		//position: 'se',        // => position of the value box (default south-east)
		//relative: false,       // => next to the mouse cursor
		//trackFormatter: Flotr.defaultTrackFormatter, // => formats the values in the value box
		//margin: 5,             // => margin in pixels of the valuebox
		//lineColor: '#FF3F19',  // => line color of points that are drawn when mouse comes near a value of a series
		//trackDecimals: 1,      // => decimals for the track values
		//sensibility: 2,        // => the lower this number, the more precise you have to aim to show a value
		//trackY: true,          // => whether or not to track the mouse in the y axis
		//radius: 3,             // => radius of the track point
		//fillColor: null,       // => color to fill our select bar with only applies to bar and similar graphs (only bars for now)
		//fillOpacity: 0.4       // => opacity of the fill color, set to 1 for a solid fill, 0 hides the fill 
	}
	
	public static class Legend {
		
		public String position;
		public String backgroundColor = "#D2E8FF";
		
		public Legend(String position) {
			this.position = position;
		}
	}
	
	public static class PieOption {
		public boolean fill = true;
		public double fillOpacity = 0.5;
		public double explode = 0.0;
		public double startAngle = 0.75;
	}
	
	public static class PieData {
		public String label;
		public double[][] data;
		public Map<String, Object> pie;//options
		
		public PieData(String label, double data) {
			this(label, data, 0);
		}
		
		public PieData(String label, double data, double explode) {
			this.label = label;
			this.data = new double[1][2];
			this.data[0][1] = data;
			if (explode != 0) {
				this.pie = new HashMap<String, Object>();
				this.pie.put("explode", explode);
			}
		}
	}
	
	public static class BarOption {
		public boolean horizontal;
		public double barWidth = 0.5;
		public boolean stacked;
	}
	
	public static class SeriesData {
		
		private transient boolean horizontal;
		private transient int seriesCount;
		private transient int offset;
		public String label;
		public List<double[]> data = new ArrayList<double[]>();
		
		public SeriesData(String label, boolean horizontal, int seriesCount, int offset) {
			this.label = label;
			this.horizontal = horizontal;
			this.seriesCount = seriesCount;
			this.offset = offset;
		}
		
		public void addData(double d) {
			int n = this.seriesCount == 0 ?
				this.data.size() + 1 :
				(this.data.size() * (this.seriesCount + 1)) + this.offset + 1;
			
			double[] row = new double[2];
			if (this.horizontal) {
				row[0] = d;
				row[1] = n;
			} else {
				row[0] = n;
				row[1] = d;
			}
			this.data.add(row);
		}
		
		public void addData(double x, double y) {
			double[] row = new double[2];
			if (this.horizontal) {
				row[0] = y;
				row[1] = x;
			} else {
				row[0] = x;
				row[1] = y;
			}
			this.data.add(row);
		}
		
		public boolean isTarget(String name) {
			if (name == null) {
				return this.label == null;
			} else {
				return name.equals(this.label);
			}
		}
	}
	
	public static class LineOption {
		public boolean stacked;
	}
	
	public static class RadarOption {
		public boolean fill;
	}
	
	public static class BubbleOption {
		public double baseRadius;
		
		public BubbleOption(double baseRadius) {
			this.baseRadius = baseRadius;
		}
	}
	
	public static class BubbleData extends SeriesData {
		
		public BubbleData(String label) {
			super(label, false, 0, 0);
		}
		
		public void addBubble(double x, double y, double size) {
			double[] row = new double[3];
			row[0] = x;
			row[1] = y;
			row[2] = size;
			this.data.add(row);
		}
	}
	
	public List<String> getCellNames() {
		if (this.cellNames == null) {
			return null;
		}
		List<String> list = new ArrayList<String>();
		for (String[] strs : this.cellNames.values()) {
			for (String s : strs) {
				list.add(s);
			}
		}
		return list;
	}
	void setCellNames(List<NameInfo[]> list) {
		this.cellNames = new LinkedHashMap<String, String[]>();
		int titleCnt = 0;
		int nameCnt = 0;
		int valCnt = 0;
		for (NameInfo[] names : list) {
			char c = names[0].getType();
			int idx = 0;
			switch (c) {
				case NameInfo.TYPE_TITLE:
					idx = titleCnt++;
					break;
				case NameInfo.TYPE_NAME:
					idx = nameCnt++;
					break;
				case NameInfo.TYPE_VALUE:
					idx = valCnt++;
					break;
				default:
					throw new IllegalStateException();
			}
			String key = "" + c + idx;
			String[] values = new String[names.length];
			for (int i=0; i<names.length; i++) {
				String name = names[i].getName();
				int split = name.indexOf('!');
				if (split != -1) {
					name = name.substring(split + 1);
				}
				name = name.replaceAll("\\$", "");
				values[i] = name;
			}
			this.cellNames.put(key, values);
		}
	}
	
	public boolean setCellValue(String name, Object value) {
		if (this.cellNames == null) {
			return false;
		}
		if (this.nameMap == null) {
			int titleCnt = 0;
			int nameCnt = 0;
			int valCnt = 0;
			this.nameMap = new HashMap<String, ValueInfo>();
			for (Map.Entry<String, String[]> entry : this.cellNames.entrySet()) {
				String key = entry.getKey();
				String[] values = entry.getValue();
				char type = key.charAt(0);
				int sidx = Integer.parseInt(key.substring(1));
				for (int i=0; i<values.length; i++) {
					this.nameMap.put(values[i], new ValueInfo(type, sidx, i));
				}
			}
//System.out.println("nameMap: " + nameMap);
		}
		ValueInfo vi = this.nameMap.get(name);
		if (vi == null) {
			return false;
		}
		if (value == null) {
			if (vi.type == NameInfo.TYPE_VALUE) {
				value = 0.0;
			} else {
				value = "";
			}
		} 
		switch (vi.type) {
			case NameInfo.TYPE_TITLE:
				if (this.data != null && vi.sIndex < this.data.size()) {
					SeriesData d = (SeriesData)this.data.get(vi.sIndex);
					d.label = value.toString();
					return true;
				}
				break;
			case NameInfo.TYPE_NAME:
				if (this.type == Type.PIE) {
					if (this.data != null && vi.sIndex < this.data.size()) {
						PieData d = (PieData)this.data.get(vi.sIndex);
						d.label = value.toString();
						return true;
					}
				} else {
					if (this.labels != null && vi.vIndex < this.labels.size()) {
						this.labels.set(vi.vIndex, value.toString());
						return true;
					}
				}
				break;
			case NameInfo.TYPE_VALUE:
				if (this.data == null) {
					return false;
				}
				if (!(value instanceof Double)) {
					return false;
				}
				double dValue = (Double)value;
				int dataIndex = vi.sIndex;
				switch (this.type) {
					case PIE:
						{
							dataIndex = vi.vIndex;
							if (dataIndex < this.data.size()) {
								PieData pd = (PieData)this.data.get(dataIndex);
								pd.data[0][1] = dValue;
								return true;
							}
						}
						break;
					case BUBBLE:
						{
							int mod = dataIndex % 3;
							dataIndex = dataIndex / 3;
							if (dataIndex < this.data.size()) {
								BubbleData bd = (BubbleData)this.data.get(dataIndex);
								if (bd.data != null && vi.vIndex < bd.data.size()) {
									bd.data.get(vi.vIndex)[mod] = dValue;
									return true;
								}
							}
						}
						break;
					default:
						{
							int mod = 0;
							if (this.labels == null || this.labels.size() == 0) {
								dataIndex = dataIndex / 2;
								mod = dataIndex % 2;
							} else if (!isHorizontal()) {
								mod = 1;
							}
//System.out.println("value: " + name + ", " + vi + ", " + dataIndex + ", " + mod);
							if (dataIndex < this.data.size()) {
								SeriesData sd = (SeriesData)this.data.get(dataIndex);
								if (sd.data != null && vi.vIndex < sd.data.size()) {
									sd.data.get(vi.vIndex)[mod] = dValue;
									return true;
								}
							}
						}
						break;
				}
				break;
			default:
				throw new IllegalStateException();
		}
		//ToDo
		return false;
	}
	
	public void clearRawData() {
		this.cellNames = null;
		this.nameMap = null;
	}
	
	public static class NameInfo {
		
		public static final char TYPE_TITLE = 't';
		public static final char TYPE_NAME  = 'n';
		public static final char TYPE_VALUE = 'v';
		
		private char type;
		private String name;
		
		public NameInfo(char type, String name) {
			this.type = type;
			this.name = name;
		}
		
		public char getType() { return this.type;}
		public String getName() { return this.name;}
	}
	
	private static class ValueInfo {
		
		public char type;
		public int sIndex;
		public int vIndex;
		
		public ValueInfo(char type, int sidx, int vidx) {
			this.type = type;
			this.sIndex = sidx;
			this.vIndex = vidx;
		}
		
		public String toString() { return "" + type + sIndex + "-" + vIndex;}
	}
	
	public Chart deserialize(JsonElement json, java.lang.reflect.Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
		JsonObject obj = json.getAsJsonObject();
		Type type = Type.valueOf(obj.getAsJsonPrimitive("type").getAsString());
		Flotr2 ret = new Flotr2(type);
		if (obj.has("option")) {
			ret.option = context.deserialize(obj.get("option"), Option.class);
		}
		if (obj.has("labels")) {
			ret.labels = context.deserialize(obj.get("labels"), new TypeToken<List<String>>() {}.getType());
		}
		if (obj.has("cellNames")) {
			ret.cellNames = context.deserialize(obj.get("cellNames"), new TypeToken<LinkedHashMap<String, String[]>>() {}.getType());
		}
		if (obj.has("data")) {
			JsonArray array = obj.getAsJsonArray("data");
			Iterator<JsonElement> it = array.iterator();
			while (it.hasNext()) {
				JsonElement data = it.next();
				Object value = null;
				switch (type) {
					case PIE:
						value = context.deserialize(data, PieData.class);
						break;
					case BUBBLE:
						value = context.deserialize(data, BubbleData.class);
						break;
					case BAR:
					case LINE:
					case RADAR:
						value = context.deserialize(data, SeriesData.class);
						break;
					default:
						throw new IllegalStateException();
				}
				ret.data.add(value);
			}
		}
		return ret;
	}

	public Chart cloneChart() {
		try {
			return (Chart)super.clone();
		} catch (CloneNotSupportedException e) {
			throw new IllegalStateException(e);
		}
	}
}

